"""
QuoTrading AI - Customer Launcher
==================================
Professional GUI application for easy setup and launch.
4-Screen Progressive Onboarding Flow with Validation.

Flow:
1. Screen 0: Username Creation
2. Screen 1: QuoTrading Account Setup (Email + API Key validation)
3. Screen 2: Broker Connection Setup (Prop Firm/Live Broker with validation)
4. Screen 3: Trading Preferences (Symbol selection, risk settings, launch)
"""

import tkinter as tk
from tkinter import ttk, messagebox
import os
import json
from pathlib import Path
from datetime import datetime
import sys
import subprocess
import re


class QuoTradingLauncher:
    """Professional GUI launcher for QuoTrading AI bot - Green/Black Theme."""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("QuoTrading - Professional Trading Platform")
        self.root.geometry("700x650")
        self.root.resizable(False, False)
        
        # Green and Black color scheme
        self.colors = {
            'primary': '#000000',        # Pure black background
            'secondary': '#0A0A0A',      # Near black for cards
            'success': '#00FF41',        # Matrix green (bright)
            'success_dark': '#00B82E',   # Darker green for buttons
            'error': '#FF0000',          # Red for errors
            'background': '#000000',     # Black background
            'card': '#0F0F0F',           # Dark gray card
            'text': '#00FF41',           # Bright green text
            'text_light': '#00CC33',     # Medium green
            'text_secondary': '#008822', # Dark green
            'border': '#00FF41',         # Green border
            'input_bg': '#1A1A1A',       # Dark input background
            'button_hover': '#00DD38'    # Button hover color
        }
        
        self.root.configure(bg=self.colors['background'])
        
        # Load saved config
        self.config_file = Path("config.json")
        self.config = self.load_config()
        
        # Current screen tracker
        self.current_screen = 0
        
        # Start with username screen (Screen 0)
        self.setup_username_screen()
    
    def create_header(self, title, subtitle=""):
        """Create a professional header for each screen."""
        header = tk.Frame(self.root, bg=self.colors['success_dark'], height=100)
        header.pack(fill=tk.X)
        header.pack_propagate(False)
        
        title_label = tk.Label(
            header,
            text=title,
            font=("Arial", 24, "bold"),
            bg=self.colors['success_dark'],
            fg=self.colors['background']
        )
        title_label.pack(pady=(20, 5))
        
        if subtitle:
            subtitle_label = tk.Label(
                header,
                text=subtitle,
                font=("Arial", 11),
                bg=self.colors['success_dark'],
                fg=self.colors['background']
            )
            subtitle_label.pack()
        
        return header
    
    def create_input_field(self, parent, label_text, is_password=False, placeholder=""):
        """Create a styled input field with label."""
        container = tk.Frame(parent, bg=self.colors['card'])
        container.pack(fill=tk.X, pady=10)
        
        label = tk.Label(
            container,
            text=label_text,
            font=("Arial", 12, "bold"),
            bg=self.colors['card'],
            fg=self.colors['text']
        )
        label.pack(anchor=tk.W, pady=(0, 5))
        
        entry = tk.Entry(
            container,
            font=("Arial", 12),
            bg=self.colors['input_bg'],
            fg=self.colors['text'],
            insertbackground=self.colors['success'],
            relief=tk.FLAT,
            bd=0,
            highlightthickness=2,
            highlightbackground=self.colors['border'],
            highlightcolor=self.colors['success'],
            show="‚óè" if is_password else ""
        )
        entry.pack(fill=tk.X, ipady=8, padx=2)
        
        if placeholder:
            entry.insert(0, placeholder)
            entry.config(fg=self.colors['text_secondary'])
            
            def on_focus_in(event):
                if entry.get() == placeholder:
                    entry.delete(0, tk.END)
                    entry.config(fg=self.colors['text'])
            
            def on_focus_out(event):
                if not entry.get():
                    entry.insert(0, placeholder)
                    entry.config(fg=self.colors['text_secondary'])
            
            entry.bind("<FocusIn>", on_focus_in)
            entry.bind("<FocusOut>", on_focus_out)
        
        return entry
    
    def create_button(self, parent, text, command, button_type="next"):
        """Create a styled button."""
        if button_type == "next":
            bg = self.colors['success_dark']
            fg = self.colors['background']
            width = 20
        elif button_type == "back":
            bg = self.colors['secondary']
            fg = self.colors['text']
            width = 15
        else:  # start
            bg = self.colors['success']
            fg = self.colors['background']
            width = 25
        
        button = tk.Button(
            parent,
            text=text,
            font=("Arial", 14, "bold"),
            bg=bg,
            fg=fg,
            activebackground=self.colors['button_hover'],
            activeforeground=self.colors['background'],
            relief=tk.FLAT,
            bd=0,
            command=command,
            cursor="hand2",
            width=width,
            height=2
        )
        return button
    
    def setup_username_screen(self):
        """Screen 0: Username creation screen."""
        # Clear window
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.current_screen = 0
        self.root.title("QuoTrading - Welcome")
        
        # Header
        header = self.create_header("Welcome to QuoTrading", "Create your trading profile")
        
        # Main container
        main = tk.Frame(self.root, bg=self.colors['background'], padx=40, pady=40)
        main.pack(fill=tk.BOTH, expand=True)
        
        # Card
        card = tk.Frame(main, bg=self.colors['card'], relief=tk.FLAT, bd=0)
        card.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        card.configure(highlightbackground=self.colors['border'], highlightthickness=2)
        
        # Card content
        content = tk.Frame(card, bg=self.colors['card'], padx=30, pady=30)
        content.pack(fill=tk.BOTH, expand=True)
        
        # Welcome message
        welcome = tk.Label(
            content,
            text="Create Your Username",
            font=("Arial", 18, "bold"),
            bg=self.colors['card'],
            fg=self.colors['text']
        )
        welcome.pack(pady=(0, 10))
        
        info = tk.Label(
            content,
            text="This username will be used to identify your trading profile.\nChoose something you'll remember.",
            font=("Arial", 10),
            bg=self.colors['card'],
            fg=self.colors['text_light'],
            justify=tk.CENTER
        )
        info.pack(pady=(0, 30))
        
        # Username input
        self.username_entry = self.create_input_field(content, "Username:", placeholder="Enter your username")
        
        # Instructions
        instructions = tk.Label(
            content,
            text="‚Ä¢ 3-20 characters\n‚Ä¢ Letters, numbers, and underscores only\n‚Ä¢ Will be saved to your profile",
            font=("Arial", 9),
            bg=self.colors['card'],
            fg=self.colors['text_secondary'],
            justify=tk.LEFT
        )
        instructions.pack(pady=(10, 30))
        
        # Button container
        button_frame = tk.Frame(content, bg=self.colors['card'])
        button_frame.pack(fill=tk.X, pady=20)
        
        # Next button
        next_btn = self.create_button(button_frame, "NEXT ‚Üí", self.validate_username, "next")
        next_btn.pack()
    
    def validate_username(self):
        """Validate username and proceed to QuoTrading setup."""
        username = self.username_entry.get().strip()
        
        # Remove placeholder if present
        if username == "Enter your username":
            username = ""
        
        # Validation
        if not username:
            messagebox.showerror(
                "Username Required",
                "Please enter a username to continue."
            )
            return
        
        if len(username) < 3 or len(username) > 20:
            messagebox.showerror(
                "Invalid Username",
                "Username must be between 3 and 20 characters."
            )
            return
        
        if not re.match(r'^[a-zA-Z0-9_]+$', username):
            messagebox.showerror(
                "Invalid Username",
                "Username can only contain letters, numbers, and underscores."
            )
            return
        
        # Save username to config
        self.config["username"] = username
        self.save_config()
        
        # Proceed to QuoTrading setup
        self.setup_quotrading_screen()
    
    def setup_quotrading_screen(self):
        """Screen 1: QuoTrading Account Setup with Email + API Key validation."""
        # Clear window
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.current_screen = 1
        self.root.title("QuoTrading - Account Setup")
        
        # Header
        header = self.create_header("QuoTrading Account", "Enter your subscription credentials")
        
        # Main container
        main = tk.Frame(self.root, bg=self.colors['background'], padx=40, pady=30)
        main.pack(fill=tk.BOTH, expand=True)
        
        # Card
        card = tk.Frame(main, bg=self.colors['card'], relief=tk.FLAT, bd=0)
        card.pack(fill=tk.BOTH, expand=True)
        card.configure(highlightbackground=self.colors['border'], highlightthickness=2)
        
        # Card content
        content = tk.Frame(card, bg=self.colors['card'], padx=30, pady=30)
        content.pack(fill=tk.BOTH, expand=True)
        
        # Info message
        info = tk.Label(
            content,
            text="Enter your QuoTrading subscription details.\nWe'll validate your access before proceeding.",
            font=("Arial", 11),
            bg=self.colors['card'],
            fg=self.colors['text_light'],
            justify=tk.CENTER
        )
        info.pack(pady=(0, 20))
        
        # Email input
        self.email_entry = self.create_input_field(
            content, 
            "Email Address:",
            placeholder=self.config.get("quotrading_email", "your.email@example.com")
        )
        
        # API Key input
        self.api_key_entry = self.create_input_field(
            content,
            "API Key:",
            is_password=True,
            placeholder=self.config.get("quotrading_api_key", "")
        )
        
        # Help text
        help_text = tk.Label(
            content,
            text="üìß Check your email for your API key\nüí° Contact support@quotrading.com if you need help",
            font=("Arial", 9),
            bg=self.colors['card'],
            fg=self.colors['text_secondary'],
            justify=tk.CENTER
        )
        help_text.pack(pady=(10, 20))
        
        # Button container
        button_frame = tk.Frame(content, bg=self.colors['card'])
        button_frame.pack(fill=tk.X, pady=20)
        
        # Back button
        back_btn = self.create_button(button_frame, "‚Üê BACK", self.setup_username_screen, "back")
        back_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        # Next button
        next_btn = self.create_button(button_frame, "NEXT ‚Üí", self.validate_quotrading, "next")
        next_btn.pack(side=tk.RIGHT)
    
    def validate_quotrading(self):
        """Validate QuoTrading credentials before proceeding."""
        email = self.email_entry.get().strip()
        api_key = self.api_key_entry.get().strip()
        
        # Remove placeholders
        if email == "your.email@example.com":
            email = ""
        
        # Validation
        if not email or not api_key:
            messagebox.showerror(
                "Missing Information",
                "Please enter both your email and API key."
            )
            return
        
        # Validate email format
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(email_pattern, email):
            messagebox.showerror(
                "Invalid Email",
                "Please enter a valid email address."
            )
            return
        
        # Admin master key - instant access
        if api_key == "QUOTRADING_ADMIN_MASTER_2025":
            self.config["quotrading_email"] = email
            self.config["quotrading_api_key"] = api_key
            self.config["quotrading_validated"] = True
            self.save_config()
            self.setup_broker_screen()
            return
        
        # Validate API key format (basic check)
        if len(api_key) < 20:
            messagebox.showerror(
                "Invalid API Key",
                "API key appears to be invalid.\nPlease check your email for the correct API key."
            )
            return
        
        # TODO: Make real API call to QuoTrading backend to validate credentials
        # For now, simulate validation
        messagebox.showinfo(
            "Validation",
            "‚ö†Ô∏è Note: Real API validation will be implemented.\n\nFor now, credentials are accepted if properly formatted."
        )
        
        # Save credentials
        self.config["quotrading_email"] = email
        self.config["quotrading_api_key"] = api_key
        self.config["quotrading_validated"] = True
        self.save_config()
        
        # Proceed to broker setup
        self.setup_broker_screen()
    
    def setup_broker_screen(self):
        """Setup the credentials entry screen (Screen 1)."""
        # Clear window
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.title("QuoTrading AI - Broker Setup")
        
        # Modern gradient-style header - compact
        header = tk.Frame(self.root, bg=self.colors['primary'], height=90)
        header.pack(fill=tk.X)
        header.pack_propagate(False)
        
        # Logo/Title section - centered
        title = tk.Label(
            header,
            text="QuoTrading AI",
            font=("Segoe UI", 18, "bold"),
            bg=self.colors['primary'],
            fg="white"
        )
        title.pack(pady=(12, 0))
        
        subtitle = tk.Label(
            header,
            text="Professional AI Trading",
            font=("Segoe UI", 10),
            bg=self.colors['primary'],
            fg="#93C5FD"
        )
        subtitle.pack(pady=(4, 16))
        
        # Main content area with minimal padding
        main_container = tk.Frame(self.root, bg=self.colors['background'])
        main_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=15)
        
        # Main card - minimal padding
        main = tk.Frame(main_container, bg=self.colors['card'], relief=tk.FLAT, bd=0)
        main.pack(fill=tk.BOTH, expand=True)
        main.configure(highlightbackground=self.colors['border'], highlightthickness=1)
        
        # Card content with minimal padding
        card_content = tk.Frame(main, bg=self.colors['card'])
        card_content.pack(fill=tk.BOTH, expand=True, padx=15, pady=15)
        
        # Section: QuoTrading License - very compact
        tk.Label(
            card_content,
            text="QuoTrading License",
            font=("Segoe UI", 10, "bold"),
            bg=self.colors['card'],
            fg=self.colors['text']
        ).pack(anchor=tk.W, pady=(0, 2))
        
        tk.Label(
            card_content,
            text="Enter your license key (received via email)",
            font=("Segoe UI", 7),
            bg=self.colors['card'],
            fg=self.colors['text_light']
        ).pack(anchor=tk.W, pady=(0, 4))
        
        # Modern entry field - very compact
        license_frame = tk.Frame(card_content, bg=self.colors['card'])
        license_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.license_entry = tk.Entry(
            license_frame,
            font=("Segoe UI", 8),
            relief=tk.SOLID,
            bd=1,
            highlightthickness=2,
            highlightbackground=self.colors['border'],
            highlightcolor=self.colors['secondary']
        )
        self.license_entry.pack(fill=tk.X, ipady=3)
        self.license_entry.insert(0, self.config.get("quotrading_license", ""))
        
        # Divider - very thin
        tk.Frame(card_content, height=1, bg=self.colors['border']).pack(fill=tk.X, pady=8)
        
        # Section: Market & Broker Selection - category-based
        tk.Label(
            card_content,
            text="Select Market Type",
            font=("Segoe UI", 10, "bold"),
            bg=self.colors['card'],
            fg=self.colors['text']
        ).pack(anchor=tk.W, pady=(0, 6))
        
        # Market type - Futures only (hidden, always set)
        self.market_var = tk.StringVar(value="Futures")
        
        # Broker Type selection (Prop Firm vs Live Broker) - Modern card-style buttons
        tk.Label(
            card_content,
            text="Account Type:",
            font=("Segoe UI", 10, "bold"),
            bg=self.colors['card'],
            fg=self.colors['text']
        ).pack(anchor=tk.W, pady=(0, 8))
        
        self.broker_type_var = tk.StringVar(value=self.config.get("broker_type", "Prop Firm"))
        
        # Container for card-style buttons
        broker_type_container = tk.Frame(card_content, bg=self.colors['card'])
        broker_type_container.pack(fill=tk.X, pady=(0, 12))
        
        # Create card-style selection buttons
        broker_types = [
            ("Prop Firm", "üíº", "Funded trading programs"),
            ("Live Broker", "üè¶", "Direct broker accounts")
        ]
        
        self.broker_type_buttons = {}
        for i, (btype, icon, desc) in enumerate(broker_types):
            # Card frame
            card_frame = tk.Frame(
                broker_type_container,
                bg=self.colors['background'],
                relief=tk.FLAT,
                bd=0,
                highlightthickness=2,
                highlightbackground=self.colors['border']
            )
            card_frame.pack(side=tk.LEFT, padx=(0, 10) if i == 0 else (0, 0), expand=True, fill=tk.BOTH)
            
            # Make card clickable
            def make_select(bt=btype):
                return lambda e: self.select_broker_type(bt)
            
            card_frame.bind("<Button-1>", make_select(btype))
            
            # Icon + Text inside card
            inner_frame = tk.Frame(card_frame, bg=self.colors['background'])
            inner_frame.pack(expand=True, fill=tk.BOTH, padx=15, pady=12)
            inner_frame.bind("<Button-1>", make_select(btype))
            
            # Icon
            icon_label = tk.Label(
                inner_frame,
                text=icon,
                font=("Segoe UI", 20),
                bg=self.colors['background'],
                fg=self.colors['text']
            )
            icon_label.pack()
            icon_label.bind("<Button-1>", make_select(btype))
            
            # Type text
            type_label = tk.Label(
                inner_frame,
                text=btype,
                font=("Segoe UI", 11, "bold"),
                bg=self.colors['background'],
                fg=self.colors['text']
            )
            type_label.pack(pady=(4, 2))
            type_label.bind("<Button-1>", make_select(btype))
            
            # Description
            desc_label = tk.Label(
                inner_frame,
                text=desc,
                font=("Segoe UI", 8),
                bg=self.colors['background'],
                fg=self.colors['text_light']
            )
            desc_label.pack()
            desc_label.bind("<Button-1>", make_select(btype))
            
            self.broker_type_buttons[btype] = card_frame
        
        # Broker dropdown (changes based on broker type)
        tk.Label(
            card_content,
            text="Select Broker:",
            font=("Segoe UI", 8, "bold"),
            bg=self.colors['card'],
            fg=self.colors['text']
        ).pack(anchor=tk.W, pady=(8, 3))
        
        self.broker_var = tk.StringVar(value=self.config.get("broker", "TopStep"))
        self.broker_dropdown = ttk.Combobox(
            card_content,
            textvariable=self.broker_var,
            state="readonly",
            font=("Segoe UI", 8),
            width=35
        )
        self.broker_dropdown.pack(fill=tk.X, pady=(0, 10))
        self.broker_dropdown.bind('<<ComboboxSelected>>', lambda e: self.update_broker_fields())
        
        # Divider - very thin
        tk.Frame(card_content, height=1, bg=self.colors['border']).pack(fill=tk.X, pady=8)
        
        # Section: Broker Credentials - very compact
        tk.Label(
            card_content,
            text="Broker Credentials",
            font=("Segoe UI", 10, "bold"),
            bg=self.colors['card'],
            fg=self.colors['text']
        ).pack(anchor=tk.W, pady=(0, 6))
        
        # API Token field - very compact
        self.token_label = tk.Label(
            card_content,
            text="TopStep API Token:",
            font=("Segoe UI", 8, "bold"),
            bg=self.colors['card'],
            fg=self.colors['text']
        )
        self.token_label.pack(anchor=tk.W, pady=(0, 2))
        
        token_frame = tk.Frame(card_content, bg=self.colors['card'])
        token_frame.pack(fill=tk.X, pady=(0, 6))
        
        self.token_entry = tk.Entry(
            token_frame,
            font=("Segoe UI", 8),
            show="‚óè",
            relief=tk.SOLID,
            bd=1,
            highlightthickness=2,
            highlightbackground=self.colors['border'],
            highlightcolor=self.colors['secondary']
        )
        self.token_entry.pack(fill=tk.X, ipady=3)
        self.token_entry.insert(0, self.config.get("broker_token", ""))
        
        # Username field - very compact
        self.username_label = tk.Label(
            card_content,
            text="TopStep Username/Email:",
            font=("Segoe UI", 8, "bold"),
            bg=self.colors['card'],
            fg=self.colors['text']
        )
        self.username_label.pack(anchor=tk.W, pady=(0, 2))
        
        username_frame = tk.Frame(card_content, bg=self.colors['card'])
        username_frame.pack(fill=tk.X, pady=(0, 5))
        
        self.username_entry = tk.Entry(
            username_frame,
            font=("Segoe UI", 8),
            relief=tk.SOLID,
            bd=1,
            highlightthickness=2,
            highlightbackground=self.colors['border'],
            highlightcolor=self.colors['secondary']
        )
        self.username_entry.pack(fill=tk.X, ipady=3)
        self.username_entry.insert(0, self.config.get("broker_username", ""))
        
        # Initialize broker type selection and dropdown options (after all fields exist)
        self.select_broker_type(self.broker_type_var.get())
        
        # Initialize broker dropdown options and update credential fields
        self.update_broker_dropdown()
        
        # Update labels based on saved broker
        self.update_broker_fields()
        
        # Bottom button area - very compact
        button_container = tk.Frame(main_container, bg=self.colors['background'])
        button_container.pack(fill=tk.X, pady=(10, 0))
        
        # Modern confirm button - compact
        confirm_btn = tk.Button(
            button_container,
            text="CONFIRM",
            font=("Segoe UI", 9, "bold"),
            bg=self.colors['secondary'],
            fg="white",
            activebackground=self.colors['primary'],
            activeforeground="white",
            relief=tk.FLAT,
            command=self.validate_and_continue,
            cursor="hand2",
            bd=0
        )
        confirm_btn.pack(fill=tk.X, ipady=8)
    
    def update_broker_fields(self):
        """Update field labels based on selected broker."""
        broker_full = self.broker_var.get()
        # Extract broker name (before the dash)
        broker = broker_full.split(" - ")[0] if " - " in broker_full else broker_full
        
        # Define credential requirements for each broker
        broker_credentials = {
            # Futures brokers
            "TopStep": {
                "field1_label": "TopStep API Token:",
                "field2_label": "TopStep Username/Email:",
                "field1_show": "‚óè",
                "field2_show": ""
            },
            "Tradovate": {
                "field1_label": "Tradovate API Key:",
                "field2_label": "Tradovate Username:",
                "field1_show": "‚óè",
                "field2_show": ""
            },
            "Rithmic": {
                "field1_label": "Rithmic Username:",
                "field2_label": "Rithmic Password:",
                "field1_show": "",
                "field2_show": "‚óè"
            },
            "Interactive Brokers": {
                "field1_label": "IBKR Account ID:",
                "field2_label": "IBKR Username:",
                "field1_show": "",
                "field2_show": ""
            },
            "NinjaTrader": {
                "field1_label": "NinjaTrader License Key:",
                "field2_label": "NinjaTrader Username:",
                "field1_show": "‚óè",
                "field2_show": ""
            },
            # Forex brokers
            "OANDA": {
                "field1_label": "OANDA API Token:",
                "field2_label": "OANDA Account ID:",
                "field1_show": "‚óè",
                "field2_show": ""
            },
            "FXCM": {
                "field1_label": "FXCM API Token:",
                "field2_label": "FXCM Account ID:",
                "field1_show": "‚óè",
                "field2_show": ""
            },
            "TD Ameritrade": {
                "field1_label": "TD Ameritrade API Key:",
                "field2_label": "TD Ameritrade Username:",
                "field1_show": "‚óè",
                "field2_show": ""
            },
            "IG Markets": {
                "field1_label": "IG API Key:",
                "field2_label": "IG Username:",
                "field1_show": "‚óè",
                "field2_show": ""
            },
            # Crypto brokers
            "Binance": {
                "field1_label": "Binance API Key:",
                "field2_label": "Binance API Secret:",
                "field1_show": "‚óè",
                "field2_show": "‚óè"
            },
            "Coinbase Pro": {
                "field1_label": "Coinbase API Key:",
                "field2_label": "Coinbase API Secret:",
                "field1_show": "‚óè",
                "field2_show": "‚óè"
            },
            "Kraken": {
                "field1_label": "Kraken API Key:",
                "field2_label": "Kraken Private Key:",
                "field1_show": "‚óè",
                "field2_show": "‚óè"
            },
            "Bybit": {
                "field1_label": "Bybit API Key:",
                "field2_label": "Bybit API Secret:",
                "field1_show": "‚óè",
                "field2_show": "‚óè"
            },
            "Bitget": {
                "field1_label": "Bitget API Key:",
                "field2_label": "Bitget Secret Key:",
                "field1_show": "‚óè",
                "field2_show": "‚óè"
            },
            # Options brokers
            "Tastytrade": {
                "field1_label": "Tastytrade API Token:",
                "field2_label": "Tastytrade Account Number:",
                "field1_show": "‚óè",
                "field2_show": ""
            },
            "E*TRADE": {
                "field1_label": "E*TRADE Consumer Key:",
                "field2_label": "E*TRADE Consumer Secret:",
                "field1_show": "‚óè",
                "field2_show": "‚óè"
            },
            "Charles Schwab": {
                "field1_label": "Schwab API Key:",
                "field2_label": "Schwab Account Number:",
                "field1_show": "‚óè",
                "field2_show": ""
            }
        }
        
        # Get credentials for selected broker
        creds = broker_credentials.get(broker, broker_credentials["TopStep"])
        
        # Update labels and show/hide settings
        self.token_label.config(text=creds["field1_label"])
        self.username_label.config(text=creds["field2_label"])
        self.token_entry.config(show=creds["field1_show"])
        self.username_entry.config(show=creds["field2_show"])
    
    def select_broker_type(self, broker_type):
        """Select broker type and update UI styling."""
        self.broker_type_var.set(broker_type)
        
        # Update card styling
        for btype, card in self.broker_type_buttons.items():
            if btype == broker_type:
                # Selected state - bright blue border
                card.config(
                    highlightbackground=self.colors['secondary'],
                    highlightthickness=3
                )
            else:
                # Unselected state - gray border
                card.config(
                    highlightbackground=self.colors['border'],
                    highlightthickness=2
                )
        
        # Update broker dropdown
        self.update_broker_dropdown()
    
    def update_broker_dropdown(self):
        """Update broker dropdown options based on Prop Firm vs Live Broker selection."""
        broker_type = self.broker_type_var.get()
        
        # Define brokers for each type
        if broker_type == "Prop Firm":
            broker_options = [
                "TopStep - Funded Trader Program",
                # More prop firms coming soon:
                # "Earn2Trade - Evaluation Program",
                # "The5ers - Trading Combine",
                # "FTMO - Funded Trading"
            ]
        else:  # Live Broker
            broker_options = [
                "Tradovate - Cloud-Based Platform",
                # More live brokers coming soon:
                # "Rithmic - Professional API Access",
                # "Interactive Brokers - Global Markets",
                # "NinjaTrader - Platform + Brokerage"
            ]
        
        # Update dropdown values
        self.broker_dropdown['values'] = broker_options
        
        # Set default selection
        self.broker_dropdown.current(0)
        
        # Update credential fields
        self.update_broker_fields()
    
    def update_confidence_label(self, value):
        """Update the confidence threshold display label and hint text."""
        value_int = int(float(value))
        self.confidence_value_label.config(text=f"{value_int}%")
        self.confidence_hint_label.config(text=self.get_confidence_hint(value_int))
    
    def get_confidence_hint(self, value):
        """Get helpful hint text based on confidence threshold value."""
        if value < 30:
            return "‚ö†Ô∏è Very Low - Many trades, high risk, less reliable signals"
        elif value < 50:
            return "üìà Low - More trades but lower quality, moderate risk"
        elif value < 70:
            return "‚öñÔ∏è Balanced - Good mix of trade frequency and quality"
        elif value < 85:
            return "‚ú® High - Fewer trades, higher quality, more selective"
        else:
            return "üéØ Very High - Very few trades, only highest confidence signals"
    
    def validate_and_continue(self):
        """Validate license key and move to settings screen. Broker credentials validated later."""
        broker_full = self.broker_var.get()
        broker = broker_full.split(" - ")[0] if " - " in broker_full else broker_full
        market_type = self.market_var.get()
        
        # Step 1: Validate license key (REQUIRED)
        license_key = self.license_entry.get()
        
        if not license_key:
            messagebox.showerror("Missing License Key", 
                "QuoTrading License Key is required!\n\n"
                "You should have received this via email after purchase.\n"
                "Contact support@quotrading.com if you need help.")
            return
        
        # Admin master key - instant access (bypass all checks)
        if license_key == "QUOTRADING_ADMIN_MASTER_2025":
            self.config["quotrading_license"] = license_key
            self.config["market_type"] = market_type
            self.config["broker"] = broker
            self.config["broker_token"] = self.token_entry.get() or "admin_token"
            self.config["broker_username"] = self.username_entry.get() or "admin@quotrading.com"
            self.save_config()
            self.setup_settings_screen()
            return
        
        # Validate license key format (basic check for now)
        if len(license_key) < 20:
            messagebox.showerror("Invalid License Key", 
                "License key appears to be invalid.\n\n"
                "Please check your email for the correct license key.\n"
                "Format: QUOTRADING-XXXX-XXXX-XXXX-XXXX")
            return
        
        # Step 2: Check broker credentials are entered (NOT validated yet - that happens at START TRADING)
        if not self.token_entry.get():
            messagebox.showwarning(f"Missing {broker} Credentials", 
                f"Please enter your {broker} API credentials.\n\n"
                f"You can get these from your {broker} account dashboard.\n"
                f"These will be validated when you start trading.")
            return
        
        if not self.username_entry.get():
            messagebox.showwarning(f"Missing {broker} Username", 
                f"Please enter your {broker} username/email.")
            return
        
        # Step 3: Save everything and proceed to settings screen
        self.config["quotrading_license"] = license_key
        self.config["market_type"] = market_type
        self.config["broker"] = broker
        self.config["broker_token"] = self.token_entry.get()
        self.config["broker_username"] = self.username_entry.get()
        self.save_config()
        
        # Move to settings screen (broker credentials will be validated when clicking START TRADING)
        self.setup_settings_screen()
    
    def setup_settings_screen(self):
        """Setup the trading settings screen (Screen 2)."""
        # Clear window
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.title("QuoTrading AI - Configure Trading")
        
        # Compact header
        header = tk.Frame(self.root, bg=self.colors['primary'], height=50)
        header.pack(fill=tk.X)
        header.pack_propagate(False)
        
        title = tk.Label(
            header, 
            text="QuoTrading AI - Trading Settings", 
            font=("Segoe UI", 14, "bold"),
            bg=self.colors['primary'],
            fg="white"
        )
        title.pack(pady=12)
        
        # Main container with dark background - minimal padding
        main_container = tk.Frame(self.root, bg=self.colors['background'])
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Main card with rounded appearance
        main = tk.Frame(main_container, bg=self.colors['card'], relief=tk.FLAT, bd=0)
        main.pack(fill=tk.BOTH, expand=True)
        main.configure(highlightbackground=self.colors['border'], highlightthickness=1)
        
        # Card content - minimal padding
        card_content = tk.Frame(main, bg=self.colors['card'])
        card_content.pack(fill=tk.BOTH, expand=True, padx=10, pady=3)
        
        # Trading Settings Frame (don't expand, just fill)
        settings = tk.Frame(card_content, bg=self.colors['card'])
        settings.pack(fill=tk.X, expand=False, pady=(0, 5))
        
        # Section 1: Trading Symbols - Checkbox Grid
        tk.Label(
            settings, 
            text="Trading Symbols", 
            font=("Segoe UI", 11, "bold"), 
            bg=self.colors['card'],
            fg=self.colors['text']
        ).pack(anchor=tk.W, pady=(0, 5))
        
        # Checkbox grid for symbols
        symbol_grid = tk.Frame(settings, bg=self.colors['card'])
        symbol_grid.pack(fill=tk.X, pady=(0, 3))
        
        # Available symbols - All major futures contracts
        self.all_symbols = [
            ("ES", "E-mini S&P 500"),
            ("NQ", "E-mini Nasdaq 100"),
            ("YM", "E-mini Dow"),
            ("RTY", "E-mini Russell 2000"),
            ("CL", "Crude Oil"),
            ("GC", "Gold"),
            ("NG", "Natural Gas"),
            ("6E", "Euro FX"),
            ("ZN", "10-Year Treasury Note"),
            ("MES", "Micro E-mini S&P 500"),
            ("MNQ", "Micro E-mini Nasdaq 100")
        ]
        
        # Store checkbox variables
        self.symbol_vars = {}
        saved_symbols = self.config.get("symbols", ["ES"])
        if isinstance(saved_symbols, str):
            saved_symbols = [saved_symbols]
        
        # Create 2-column grid of checkboxes
        for i, (code, name) in enumerate(self.all_symbols):
            row = i // 2
            col = i % 2
            
            var = tk.BooleanVar(value=(code in saved_symbols))
            self.symbol_vars[code] = var
            
            cb_frame = tk.Frame(symbol_grid, bg=self.colors['card'])
            cb_frame.grid(row=row, column=col, sticky=tk.W, padx=(0, 20), pady=1)
            
            cb = tk.Checkbutton(
                cb_frame,
                text=f"{code} - {name}",
                variable=var,
                font=("Segoe UI", 9),
                bg=self.colors['card'],
                fg=self.colors['text'],
                selectcolor=self.colors['background'],
                activebackground=self.colors['card'],
                activeforeground=self.colors['secondary'],
                cursor="hand2"
            )
            cb.pack(anchor=tk.W)
        
        # Section 2: Account Size & Risk - Side by side
        account_risk_frame = tk.Frame(settings, bg=self.colors['card'])
        account_risk_frame.pack(fill=tk.X, pady=(0, 5))
        
        # Account Size (left side)
        account_col = tk.Frame(account_risk_frame, bg=self.colors['card'])
        account_col.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        tk.Label(
            account_col, 
            text="Account Size ($)", 
            font=("Segoe UI", 9),
            bg=self.colors['card'],
            fg=self.colors['text_light']
        ).pack(anchor=tk.W)
        
        account_entry_frame = tk.Frame(account_col, bg=self.colors['card'])
        account_entry_frame.pack(fill=tk.X, pady=(3, 0))
        
        self.account_entry = tk.Entry(
            account_entry_frame,
            font=("Segoe UI", 9),
            relief=tk.SOLID,
            bd=1,
            highlightthickness=2,
            highlightbackground=self.colors['border'],
            highlightcolor=self.colors['secondary']
        )
        self.account_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, ipady=2)
        self.account_entry.insert(0, self.config.get("account_size", "10000"))
        
        fetch_btn = tk.Button(
            account_entry_frame,
            text="Fetch from Broker",
            font=("Segoe UI", 7),
            bg=self.colors['secondary'],
            fg="white",
            relief=tk.FLAT,
            cursor="hand2",
            padx=8,
            pady=4,
            command=self.fetch_account_size
        )
        fetch_btn.pack(side=tk.LEFT, padx=(5, 0))
        
        # Risk per Trade (right side)
        risk_col = tk.Frame(account_risk_frame, bg=self.colors['card'])
        risk_col.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        tk.Label(
            risk_col, 
            text="Risk per Trade (%)", 
            font=("Segoe UI", 9),
            bg=self.colors['card'],
            fg=self.colors['text_light']
        ).pack(anchor=tk.W)
        
        self.risk_var = tk.DoubleVar(value=self.config.get("risk_per_trade", 1.2))
        risk_spin = ttk.Spinbox(
            risk_col,
            from_=0.5, 
            to=5.0, 
            increment=0.1, 
            textvariable=self.risk_var,
            width=15,
            format="%.1f"
        )
        risk_spin.pack(fill=tk.X, pady=(3, 0), ipady=0)
        
        # Daily Loss Limit
        daily_loss_col = tk.Frame(account_risk_frame, bg=self.colors['card'])
        daily_loss_col.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(10, 0))
        
        tk.Label(
            daily_loss_col, 
            text="Daily Loss Limit ($)", 
            font=("Segoe UI", 9),
            bg=self.colors['card'],
            fg=self.colors['text_light']
        ).pack(anchor=tk.W)
        
        self.daily_loss_var = tk.IntVar(value=self.config.get("daily_loss_limit", 2000))
        loss_spin = ttk.Spinbox(
            daily_loss_col,
            from_=500, 
            to=10000, 
            increment=100, 
            textvariable=self.daily_loss_var,
            width=15
        )
        loss_spin.pack(fill=tk.X, pady=(3, 0), ipady=0)
        
        # Section 3: Strategy Settings - 3 columns - reduce padding
        strategy_frame = tk.Frame(settings, bg=self.colors['card'])
        strategy_frame.pack(fill=tk.X, pady=(0, 3))
        
        # Max Contracts
        contracts_col = tk.Frame(strategy_frame, bg=self.colors['card'])
        contracts_col.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        tk.Label(
            contracts_col, 
            text="Max Contracts", 
            font=("Segoe UI", 9),
            bg=self.colors['card'],
            fg=self.colors['text_light']
        ).pack(anchor=tk.W)
        
        self.contracts_var = tk.IntVar(value=self.config.get("max_contracts", 3))
        contracts_spin = ttk.Spinbox(
            contracts_col,
            from_=1, 
            to=25, 
            textvariable=self.contracts_var,
            width=12
        )
        contracts_spin.pack(fill=tk.X, pady=(3, 0), ipady=0)
        
        # Min Risk/Reward
        rr_col = tk.Frame(strategy_frame, bg=self.colors['card'])
        rr_col.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        tk.Label(
            rr_col, 
            text="Min Risk/Reward", 
            font=("Segoe UI", 9),
            bg=self.colors['card'],
            fg=self.colors['text_light']
        ).pack(anchor=tk.W)
        
        self.risk_reward_var = tk.DoubleVar(value=self.config.get("min_risk_reward", 2.0))
        rr_spin = ttk.Spinbox(
            rr_col,
            from_=1.0, 
            to=5.0, 
            increment=0.1, 
            textvariable=self.risk_reward_var,
            width=12,
            format="%.1f"
        )
        rr_spin.pack(fill=tk.X, pady=(3, 0), ipady=0)
        
        # Max Trades/Day
        trades_col = tk.Frame(strategy_frame, bg=self.colors['card'])
        trades_col.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        tk.Label(
            trades_col, 
            text="Max Trades/Day", 
            font=("Segoe UI", 9),
            bg=self.colors['card'],
            fg=self.colors['text_light']
        ).pack(anchor=tk.W)
        
        self.trades_var = tk.IntVar(value=self.config.get("max_trades", 10))
        trades_spin = ttk.Spinbox(
            trades_col,
            from_=1, 
            to=50, 
            textvariable=self.trades_var,
            width=12
        )
        trades_spin.pack(fill=tk.X, pady=(3, 0), ipady=0)
        
        # Section 4: AI Confidence Threshold (new slider control)
        confidence_frame = tk.Frame(settings, bg=self.colors['card'])
        confidence_frame.pack(fill=tk.X, pady=(8, 3))
        
        # Label with explanation
        confidence_label_frame = tk.Frame(confidence_frame, bg=self.colors['card'])
        confidence_label_frame.pack(fill=tk.X, pady=(0, 3))
        
        tk.Label(
            confidence_label_frame,
            text="AI Confidence Threshold",
            font=("Segoe UI", 9, "bold"),
            bg=self.colors['card'],
            fg=self.colors['text']
        ).pack(side=tk.LEFT, anchor=tk.W)
        
        # Info icon with helpful message
        confidence_info = tk.Label(
            confidence_label_frame,
            text="‚ìò",
            font=("Segoe UI", 10, "bold"),
            bg=self.colors['card'],
            fg=self.colors['secondary'],
            cursor="hand2"
        )
        confidence_info.pack(side=tk.LEFT, anchor=tk.W, padx=(5, 0))
        
        # Bind hover tooltip
        def show_confidence_tooltip(event):
            tooltip_text = (
                "Lower threshold = More trades but less selective\n"
                "Higher threshold = Fewer trades but higher quality\n\n"
                "The AI calculates confidence for each signal.\n"
                "Only signals above your threshold are taken."
            )
            # Simple tooltip using label (basic implementation)
            pass
        
        confidence_info.bind("<Enter>", show_confidence_tooltip)
        
        # Current value display
        self.confidence_var = tk.IntVar(value=int(self.config.get("rl_confidence_threshold", 0.5) * 100))
        
        self.confidence_value_label = tk.Label(
            confidence_label_frame,
            text=f"{self.confidence_var.get()}%",
            font=("Segoe UI", 9, "bold"),
            bg=self.colors['card'],
            fg=self.colors['success']
        )
        self.confidence_value_label.pack(side=tk.RIGHT, anchor=tk.E)
        
        # Slider
        slider_frame = tk.Frame(confidence_frame, bg=self.colors['card'])
        slider_frame.pack(fill=tk.X, pady=(0, 3))
        
        self.confidence_slider = tk.Scale(
            slider_frame,
            from_=10,
            to=100,
            orient=tk.HORIZONTAL,
            variable=self.confidence_var,
            showvalue=0,
            bg=self.colors['card'],
            fg=self.colors['text'],
            troughcolor=self.colors['background'],
            activebackground=self.colors['secondary'],
            highlightthickness=0,
            command=self.update_confidence_label
        )
        self.confidence_slider.pack(fill=tk.X)
        
        # Helper text based on value
        self.confidence_hint_label = tk.Label(
            confidence_frame,
            text=self.get_confidence_hint(self.confidence_var.get()),
            font=("Segoe UI", 7, "italic"),
            bg=self.colors['card'],
            fg=self.colors['text_secondary'],
            justify=tk.LEFT
        )
        self.confidence_hint_label.pack(anchor=tk.W, pady=(0, 0))
        
        # Section 5: Auto-Calculate Toggle & Shadow Mode (compact row)
        toggles_frame = tk.Frame(settings, bg=self.colors['card'])
        toggles_frame.pack(fill=tk.X, pady=(3, 0))
        
        # Left column: Auto-calculate
        self.auto_calculate_var = tk.BooleanVar(value=self.config.get("auto_calculate_limits", True))
        auto_check = tk.Checkbutton(
            toggles_frame,
            text="Auto-calculate Limits",
            variable=self.auto_calculate_var,
            font=("Segoe UI", 9),
            bg=self.colors['card'],
            fg=self.colors['text'],
            selectcolor=self.colors['background'],
            activebackground=self.colors['card'],
            activeforeground=self.colors['secondary'],
            cursor="hand2"
        )
        auto_check.pack(side=tk.LEFT, anchor=tk.W)
        
        # Right column: Shadow mode (compact)
        self.shadow_mode_var = tk.BooleanVar(value=self.config.get("shadow_mode", False))
        shadow_check = tk.Checkbutton(
            toggles_frame,
            text="üåô Shadow Mode",
            variable=self.shadow_mode_var,
            font=("Segoe UI", 9),
            bg=self.colors['card'],
            fg=self.colors['warning'],
            selectcolor=self.colors['background'],
            activebackground=self.colors['card'],
            activeforeground=self.colors['warning'],
            cursor="hand2"
        )
        shadow_check.pack(side=tk.LEFT, anchor=tk.W, padx=(20, 0))
        
        # Shadow mode explanation (small text below)
        shadow_info = tk.Label(
            settings,
            text="Shadow mode = Simulates full trading with live data (no account login, tracks positions/P&L locally)",
            font=("Segoe UI", 7, "italic"),
            bg=self.colors['card'],
            fg=self.colors['text_secondary'],
            justify=tk.LEFT
        )
        shadow_info.pack(anchor=tk.W, pady=(2, 0))
        
        # Separator line - reduce padding
        separator = tk.Frame(card_content, bg=self.colors['border'], height=1)
        separator.pack(fill=tk.X, pady=(3, 5))
        
        # Button Container - Side by side
        button_container = tk.Frame(card_content, bg=self.colors['card'])
        button_container.pack(fill=tk.X, pady=(0, 5))
        
        # Start Bot Button (left)
        self.start_btn = tk.Button(
            button_container,
            text="‚ñ∂ Start Bot",
            font=("Segoe UI", 11, "bold"),
            bg=self.colors['success'],
            fg="white",
            activebackground="#059669",
            activeforeground="white",
            command=self.start_bot,
            cursor="hand2",
            relief=tk.FLAT,
            bd=0
        )
        self.start_btn.pack(side=tk.LEFT, fill=tk.X, expand=True, ipady=6, padx=(0, 5))
        
        # Stop Bot Button (right)
        self.stop_btn = tk.Button(
            button_container,
            text="‚ñ† Stop Bot",
            font=("Segoe UI", 11, "bold"),
            bg="#EF4444",
            fg="white",
            activebackground="#DC2626",
            activeforeground="white",
            command=self.stop_bot,
            cursor="hand2",
            relief=tk.FLAT,
            bd=0,
            state=tk.DISABLED  # Disabled until bot starts
        )
        self.stop_btn.pack(side=tk.LEFT, fill=tk.X, expand=True, ipady=6, padx=(5, 0))
        
        # Store bot process reference
        self.bot_process = None
        
        # Track last trade timestamp to avoid duplicate displays
        self.last_trade_timestamp = None
        self.last_daily_timestamp = None
        
        # Start polling for trade updates (every 2 seconds)
        self.poll_trade_updates()
        
        # Console/Status Frame (compact)
        console_separator = tk.Frame(card_content, bg=self.colors['border'], height=1)
        console_separator.pack(fill=tk.X, pady=(5, 3))
        
        console_label = tk.Label(
            card_content,
            text="üìä Trade Summary",
            font=("Segoe UI", 9, "bold"),
            bg=self.colors['card'],
            fg=self.colors['text']
        )
        console_label.pack(anchor=tk.W, pady=(0, 3))
        
        # Trade summary console (8 lines for better visibility)
        console_frame = tk.Frame(card_content, bg=self.colors['background'])
        console_frame.pack(fill=tk.X)
        
        self.console_text = tk.Text(
            console_frame,
            height=8,
            font=("Consolas", 8),
            bg="#0a0a0a",
            fg="#00ff00",
            insertbackground="#00ff00",
            relief=tk.FLAT,
            padx=8,
            pady=5,
            wrap=tk.WORD
        )
        self.console_text.pack(fill=tk.X)
        
        # Initial console message
        self.console_log("Ready to trade - Configure settings and click 'Start Bot'")
        self.console_text.config(state=tk.DISABLED)
    
    def fetch_account_size(self):
        """Fetch account size from broker credentials."""
        # Get broker credentials
        broker = self.config.get("broker", "TopStep")
        broker_token = self.config.get("broker_token", "")
        broker_username = self.config.get("broker_username", "")
        
        if not broker_token or not broker_username:
            messagebox.showwarning(
                "Credentials Required",
                f"Please enter your {broker} credentials first!\n\n"
                f"API Token and Username are required to fetch account balance."
            )
            return
        
        # Show working dialog
        result = messagebox.showinfo(
            "Fetching Balance...",
            f"Connecting to {broker} to fetch account balance...\n\n"
            f"This feature requires the bot to be running.\n"
            f"For now, please enter your account size manually.\n\n"
            f"Future update: Real-time balance fetching!"
        )
        
        # TODO: Implement actual broker API call when bot is running
        # For now, suggest common account sizes
        suggested = messagebox.askyesno(
            "Suggest Account Size?",
            "Would you like to use a common account size?\n\n"
            "TopStep Account Sizes:\n"
            "‚Ä¢ Express: $25,000\n"
            "‚Ä¢ Step 1: $50,000\n"
            "‚Ä¢ Step 2: $100,000 or $150,000\n\n"
            "Click YES to select, NO to enter manually."
        )
        
        if suggested:
            # Show selection dialog
            from tkinter import simpledialog
            choice = simpledialog.askstring(
                "Select Account Size",
                "Enter account size:\n"
                "25000 (Express)\n"
                "50000 (Step 1)\n"
                "100000 (Step 2)\n"
                "150000 (Step 2 Large)\n"
            )
            if choice and choice.isdigit():
                self.account_entry.delete(0, tk.END)
                self.account_entry.insert(0, choice)
    
    def load_config(self):
        """Load saved configuration."""
        if self.config_file.exists():
            try:
                with open(self.config_file) as f:
                    return json.load(f)
            except:
                pass
        return {}
    
    def save_config(self):
        """Save current configuration (only saves what exists)."""
        config = self.config.copy()  # Start with existing config
        
        # Try to save credentials if they still exist (Screen 1)
        try:
            if hasattr(self, 'license_entry'):
                config["quotrading_license"] = self.license_entry.get()
        except:
            pass
        
        try:
            if hasattr(self, 'token_entry'):
                config["broker_token"] = self.token_entry.get()
        except:
            pass
        
        try:
            if hasattr(self, 'username_entry'):
                config["broker_username"] = self.username_entry.get()
        except:
            pass
        
        # Save trading settings if they exist (Screen 2)
        try:
            if hasattr(self, 'symbol_vars'):
                # Get selected symbols from checkboxes
                selected_symbols = [code for code, var in self.symbol_vars.items() if var.get()]
                config["symbols"] = selected_symbols if selected_symbols else ["ES"]
        except:
            pass
        
        try:
            if hasattr(self, 'account_entry'):
                config["account_size"] = self.account_entry.get()
        except:
            pass
        
        try:
            if hasattr(self, 'contracts_var'):
                config["max_contracts"] = self.contracts_var.get()
        except:
            pass
        
        try:
            if hasattr(self, 'trades_var'):
                config["max_trades"] = self.trades_var.get()
        except:
            pass
        
        try:
            if hasattr(self, 'risk_var'):
                config["risk_per_trade"] = self.risk_var.get()
        except:
            pass
        
        try:
            if hasattr(self, 'risk_reward_var'):
                config["min_risk_reward"] = self.risk_reward_var.get()
        except:
            pass
        
        try:
            if hasattr(self, 'daily_loss_var'):
                config["daily_loss_limit"] = self.daily_loss_var.get()
        except:
            pass
        
        try:
            if hasattr(self, 'auto_calculate_var'):
                config["auto_calculate_limits"] = self.auto_calculate_var.get()
        except:
            pass
        
        try:
            if hasattr(self, 'shadow_mode_var'):
                config["shadow_mode"] = self.shadow_mode_var.get()
        except:
            pass
        
        try:
            if hasattr(self, 'confidence_var'):
                # Convert from percentage (10-100) to decimal (0.1-1.0)
                config["rl_confidence_threshold"] = self.confidence_var.get() / 100.0
        except:
            pass
        
        with open(self.config_file, 'w') as f:
            json.dump(config, f, indent=2)
    
    def console_log(self, message):
        """Add message to console with timestamp."""
        if not hasattr(self, 'console_text'):
            return  # Console not initialized yet
        from datetime import datetime
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.console_text.config(state=tk.NORMAL)
        self.console_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.console_text.see(tk.END)  # Auto-scroll to bottom
        self.console_text.config(state=tk.DISABLED)
    
    def show_trade_summary(self, trade_data):
        """Display a clean trade summary in the GUI console.
        
        Example trade_data:
        {
            'symbol': 'ES',
            'direction': 'LONG',
            'entry_price': 4500.00,
            'exit_price': 4506.25,
            'contracts': 2,
            'pnl': 156.25,
            'pnl_percent': 0.31
        }
        """
        if not hasattr(self, 'console_text'):
            return
        
        symbol = trade_data.get('symbol', '?')
        direction = trade_data.get('direction', '?')
        entry = trade_data.get('entry_price', 0)
        exit_price = trade_data.get('exit_price', 0)
        contracts = trade_data.get('contracts', 0)
        pnl = trade_data.get('pnl', 0)
        pnl_pct = trade_data.get('pnl_percent', 0)
        
        # Format profit/loss with color indication
        pnl_symbol = '+' if pnl >= 0 else ''
        
        # Create clean summary line
        summary = f"{symbol} {direction} @ {entry:.2f} ‚Üí EXIT @ {exit_price:.2f} | {pnl_symbol}${pnl:.2f} ({pnl_symbol}{pnl_pct:.2f}%)"
        
        self.console_log(summary)
    
    def update_daily_summary(self, daily_stats):
        """Update daily statistics in the GUI console.
        
        Example daily_stats:
        {
            'total_pnl': 406.25,
            'wins': 2,
            'losses': 0,
            'account_balance': 50406.25
        }
        """
        if not hasattr(self, 'console_text'):
            return
        
        pnl = daily_stats.get('total_pnl', 0)
        wins = daily_stats.get('wins', 0)
        losses = daily_stats.get('losses', 0)
        balance = daily_stats.get('account_balance', 0)
        
        pnl_symbol = '+' if pnl >= 0 else ''
        
        summary = f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        self.console_log(summary)
        self.console_log(f"Today: {pnl_symbol}${pnl:.2f} | {wins}W, {losses}L | Balance: ${balance:,.2f}")
        self.console_log(summary)
    
    def poll_trade_updates(self):
        """Poll for new trade data from bot and display in GUI."""
        try:
            # Check for new trade summary
            trade_file = Path('trade_summary.json')
            if trade_file.exists():
                try:
                    with open(trade_file, 'r') as f:
                        trade_data = json.load(f)
                    
                    # Check if this is a new trade (avoid duplicates)
                    trade_timestamp = trade_data.get('timestamp')
                    if trade_timestamp and trade_timestamp != self.last_trade_timestamp:
                        self.last_trade_timestamp = trade_timestamp
                        self.show_trade_summary(trade_data)
                except (json.JSONDecodeError, IOError):
                    pass  # File might be being written, skip this poll
            
            # Check for daily summary updates
            daily_file = Path('daily_summary.json')
            if daily_file.exists():
                try:
                    with open(daily_file, 'r') as f:
                        daily_data = json.load(f)
                    
                    # Check if daily stats changed
                    daily_timestamp = daily_data.get('timestamp')
                    if daily_timestamp and daily_timestamp != self.last_daily_timestamp:
                        self.last_daily_timestamp = daily_timestamp
                        self.update_daily_summary(daily_data)
                except (json.JSONDecodeError, IOError):
                    pass  # File might be being written, skip this poll
        
        except Exception as e:
            # Silently ignore errors (file access, etc.)
            pass
        
        # Schedule next poll in 2000ms (2 seconds)
        self.root.after(2000, self.poll_trade_updates)
    
    def stop_bot(self):
        """Stop the running bot process."""
        if self.bot_process is None or self.bot_process.poll() is not None:
            messagebox.showinfo(
                "No Bot Running",
                "No bot process is currently running."
            )
            return
        
        result = messagebox.askyesno(
            "Stop Bot?",
            "‚ö† Stop Trading Bot ‚ö†\n\n"
            "This will stop the bot process.\n"
            "Any open positions will remain open!\n\n"
            "Are you sure?"
        )
        
        if result:
            try:
                self.console_log("Stopping bot process...")
                self.bot_process.terminate()
                self.bot_process.wait(timeout=5)
                self.bot_process = None
                
                # Update UI
                self.start_btn.config(state=tk.NORMAL)
                self.stop_btn.config(state=tk.DISABLED)
                
                self.console_log("‚úì Bot stopped successfully")
                messagebox.showinfo(
                    "Bot Stopped",
                    "‚úì Bot process terminated.\n\n"
                    "IMPORTANT: Check broker for any open positions!"
                )
            except Exception as e:
                self.console_log(f"‚úó Failed to stop bot: {e}")
                messagebox.showerror(
                    "Stop Failed",
                    f"Failed to stop bot:\n{str(e)}"
                )
    
    def kill_bot(self):
        """Legacy method - redirects to stop_bot."""
        self.stop_bot()
    
    def start_bot(self):
        """Validate broker credentials and start the trading bot."""
        # Step 0: Validate at least one symbol is selected
        selected_symbols = [code for code, var in self.symbol_vars.items() if var.get()]
        
        if not selected_symbols:
            self.console_log("‚úó Error: No symbols selected")
            messagebox.showerror(
                "No Symbols Selected",
                "‚ö† Please select at least one symbol to trade!\n\n"
                "Use the checkboxes to choose ES, NQ, GC, or other instruments."
            )
            return
        
        # Step 1: Validate broker credentials (required for both live and shadow mode)
        broker = self.config.get("broker", "TopStep")
        broker_token = self.config.get("broker_token", "")
        broker_username = self.config.get("broker_username", "")
        license_key = self.config.get("quotrading_license", "")
        shadow_mode = self.shadow_mode_var.get()
        
        # Validate broker credentials (required even in shadow mode for live data streaming)
        # Admin key bypasses broker validation
        if license_key != "QUOTRADING_ADMIN_MASTER_2025":
            # Validate broker credentials are present
            if not broker_token or not broker_username:
                self.console_log("‚úó Error: Missing broker credentials")
                mode_desc = "simulated trading with live data (no account)" if shadow_mode else "live trading"
                messagebox.showerror(
                    "Missing Broker Credentials",
                    f"Your {broker} credentials are required for {mode_desc}!\n\n"
                    f"Shadow mode simulates full trading using live market data\n"
                    f"without logging into your trading account.\n\n"
                    f"Please go back and enter your API credentials."
                )
                return
        
        if shadow_mode:
            self.console_log("üåô Shadow mode enabled - simulating trades with live data (no account)")
        
        # Step 2: Save final config
        self.console_log("Saving configuration...")
        self.save_config()
        
        # Step 3: Create .env file
        self.console_log("Creating .env file...")
        self.create_env_file()
        
        # Step 4: Show confirmation
        symbols_str = ", ".join(selected_symbols)
        mode_str = "üåô Shadow Mode (Simulated Trading)" if shadow_mode else f"{broker} Live Trading"
        
        result = messagebox.askyesno(
            "Launch Trading Bot?",
            f"Ready to start bot with these settings:\n\n"
            f"Mode: {mode_str}\n"
            f"Broker: {broker}\n"
            f"Symbols: {symbols_str}\n"
            f"Max Contracts: {self.contracts_var.get()}\n"
            f"Max Trades/Day: {self.trades_var.get()}\n"
            f"Risk/Trade: {self.risk_var.get()}%\n"
            f"Min R:R Ratio: {self.risk_reward_var.get()}:1\n"
            f"Daily Loss Limit: ${self.daily_loss_var.get()}\n\n"
            f"{'‚ö†Ô∏è Shadow Mode: Simulates full trading with live data\n(tracks positions/P&L locally without account login).\n\n' if shadow_mode else ''}"
            f"This will open a PowerShell terminal with live logs.\n"
            f"Use the STOP BOT button to stop trading.\n\n"
            f"Continue?"
        )
        
        if not result:
            self.console_log("Launch cancelled by user")
            return
        
        # Launch bot in PowerShell terminal
        try:
            self.console_log(f"Launching bot for {symbols_str}...")
            
            # Get the parent directory (where run.py is located)
            bot_dir = Path(__file__).parent.parent.absolute()
            
            # PowerShell command to run the bot
            ps_command = [
                "powershell.exe",
                "-NoExit",  # Keep window open
                "-Command",
                f"cd '{bot_dir}'; python run.py"
            ]
            
            # Start PowerShell process in a NEW SYSTEM WINDOW
            self.bot_process = subprocess.Popen(
                ps_command, 
                creationflags=subprocess.CREATE_NEW_CONSOLE,
                cwd=str(bot_dir)
            )
            
            # Update UI
            self.start_btn.config(state=tk.DISABLED)
            self.stop_btn.config(state=tk.NORMAL)
            
            # Log success
            self.console_log(f"‚úì Bot launched successfully (PID: {self.bot_process.pid})")
            self.console_log(f"Mode: {mode_str}")
            self.console_log(f"Symbols: {symbols_str}")
            self.console_log("PowerShell terminal opened - check for live logs")
            self.console_log("Use 'Stop Bot' button to stop trading")
            
            # Success notification (don't close GUI)
            messagebox.showinfo(
                "Bot Launched!",
                f"‚úì Bot launched successfully!\n\n"
                f"Mode: {mode_str}\n"
                f"Symbols: {symbols_str}\n\n"
                f"PowerShell terminal opened with live logs.\n"
                f"This window will stay open for monitoring.\n"
                f"Use the STOP BOT button to stop trading."
            )
            
        except Exception as e:
            self.console_log(f"‚úó Launch failed: {e}")
            messagebox.showerror(
                "Launch Error",
                f"Failed to launch bot:\n{str(e)}\n\n"
                f"Make sure Python is installed and run.py exists."
            )
    
    def create_env_file(self):
        """Create .env file from GUI settings."""
        # Get selected symbols from checkboxes (NOT from config)
        selected_symbols = [code for code, var in self.symbol_vars.items() if var.get()]
        if not selected_symbols:
            selected_symbols = ["ES"]  # Fallback
        
        symbols_str = ",".join(selected_symbols)
        
        broker = self.config.get("broker", "TopStep")
        
        # Get the bot directory (parent of customer folder)
        bot_dir = Path(__file__).parent.parent.absolute()
        env_path = bot_dir / '.env'
        
        env_content = f"""# QuoTrading AI - Auto-generated Configuration
# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# DO NOT EDIT MANUALLY - Use the launcher to change settings

# License & API Keys
QUOTRADING_LICENSE_KEY={self.config.get("quotrading_license", "")}
BROKER={broker}
BROKER_API_TOKEN={self.config.get("broker_token", "")}
BROKER_USERNAME={self.config.get("broker_username", "")}

# Legacy TopStep/Tradovate variables (for compatibility)
TOPSTEP_API_TOKEN={self.config.get("broker_token", "")}
TOPSTEP_USERNAME={self.config.get("broker_username", "")}
TRADOVATE_API_KEY={self.config.get("broker_token", "")}
TRADOVATE_USERNAME={self.config.get("broker_username", "")}

# Trading Configuration - Multi-Symbol Support
# SELECTED SYMBOLS: {symbols_str}
BOT_INSTRUMENTS={symbols_str}
BOT_MAX_CONTRACTS={self.contracts_var.get()}
BOT_MAX_TRADES_PER_DAY={self.trades_var.get()}
BOT_RISK_PER_TRADE={self.risk_var.get() / 100}
BOT_MIN_RISK_REWARD={self.risk_reward_var.get()}
BOT_DAILY_LOSS_LIMIT={self.daily_loss_var.get()}
BOT_AUTO_CALCULATE_LIMITS={str(self.auto_calculate_var.get()).lower()}

# Trading Mode
BOT_SHADOW_MODE={str(self.shadow_mode_var.get()).lower()}
BOT_DRY_RUN=false

# Environment
BOT_ENVIRONMENT=production
CONFIRM_LIVE_TRADING=1
BOT_LOG_LEVEL=INFO
QUOTRADING_API_URL=https://api.quotrading.com/v1/signals
"""
        
        with open(env_path, 'w') as f:
            f.write(env_content)
        
        # Log which symbols were saved
        print(f"‚úì .env file created with {len(selected_symbols)} symbols: {symbols_str}")
    
    def run(self):
        """Start the GUI application."""
        self.root.mainloop()


if __name__ == "__main__":
    app = QuoTradingLauncher()
    app.run()
